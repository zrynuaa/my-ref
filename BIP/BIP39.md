# BIP39

[TOC]

BIP39原文地址：https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
```
BIP: 39
  Layer: Applications
  Title: Mnemonic code for generating deterministic keys 用于生成确定性密钥的助记符
  Author: Marek Palatinus <slush@satoshilabs.com>
          Pavol Rusnak <stick@satoshilabs.com>
          Aaron Voisine <voisine@gmail.com>
          Sean Bowe <ewillbefull@gmail.com>
  Comments-Summary: Unanimously Discourage for implementation
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0039
  Status: Proposed
  Type: Standards Track
  Created: 2013-09-10
```

## Abstract

This BIP describes the implementation of a mnemonic code or mnemonic sentence -- a group of easy to remember words -- for the generation of deterministic wallets.

It consists of two parts: generating the mnemonic, and converting it into a binary seed. This seed can be later used to generate deterministic wallets using BIP-0032 or similar methods.

```
描述了一个使用助记符或者助记语句（一些方便记忆的词组成）来生成确定性钱包。其包含两部分：生成助记符、根据助记符生成密钥种子seed。有了这个种子，可以使用BIP32或者其他类似的方法来生成确定性钱包。
```


## Motivation

A mnemonic code or sentence is superior for human interaction compared to the handling of raw binary or hexadecimal representations of a wallet seed. The sentence could be written on paper or spoken over the telephone.

This guide is meant to be a way to transport computer-generated randomness with a human readable transcription. It's not a way to process user-created sentences (also known as brainwallets) into a wallet seed.

```
助记符相对于二进制、十六进制的seed来说，对人是相当友好的。这是一个将随机生成的随机值randomness转换为人类可读的形式（即助记符），而不是将人生成的句子转换成seed。
```

**就是说，助记符是要由计算机随机生成，再转换为seed。不能由用户自定义助记符。**

## Generating the mnemonic

The mnemonic must encode entropy in a multiple of 32 bits. With more entropy security is improved but the sentence length increases. We refer to the initial entropy length as ENT. The allowed size of ENT is 128-256 bits.

First, an initial entropy of ENT bits is generated. A checksum is generated by taking the first
**$ENT / 32$** bits of its SHA256 hash. This checksum is appended to the end of the initial entropy. Next, these concatenated bits are split into groups of 11 bits, each encoding a number from 0-2047, serving as an index into a wordlist. Finally, we convert these numbers into words and use the joined words as a mnemonic sentence.

The following table describes the relation between the initial entropy length (ENT), the checksum length (CS) and the length of the generated mnemonic sentence (MS) in words.

```
CS = ENT / 32
MS = (ENT + CS) / 11

|  ENT  | CS | ENT+CS |  MS  |
+-------+----+--------+------+
|  128  |  4 |   132  |  12  |
|  160  |  5 |   165  |  15  |
|  192  |  6 |   198  |  18  |
|  224  |  7 |   231  |  21  |
|  256  |  8 |   264  |  24  |
这张表描述了几个变量之间单位的关系。
```

```
熵（entropy）的长度必须是32 bit的倍数，长度越长安全性越高。 初始熵长度称为ENT。允许的ENT值为128-256位。
下面是从熵生成助记符的过程： 
	1、生成一个初试熵 Entropy，长度为 ENT； 
    2、求 Entropy 的 SHA256 哈希值 hash； 
    3、取 hash 的前面 ENT/32 bits 追加到原始 Entropy 的后面，得到新的熵 newEntropy； 
    4、将 newEntropy 按照 11bit 长度分割为多个 （0-2047十进制） 大小的数（11位二进制转换位十进制）； 
    5、相应的十进制数（0-2047）对应wordlist中的一个词； 
    6、最后，将所有的词组合起来形成助记符 mnemonic sentence（一个句子）。
```

**总结：生成一个规定长度的随机值（熵），通过哈希算法得到需要的长度，分解为固定长度大小的值，根据值在wordlist找到对应的词或者句子，将所有词语组合起来形成助记符。**

## Wordlist

An ideal wordlist has the following characteristics:

a) smart selection of words

```
   - the wordlist is created in such way that it's enough to type the first four
     letters to unambiguously identify the word
```

b) similar words avoided

```
   - word pairs like "build" and "built", "woman" and "women", or "quick" and "quickly"
     not only make remembering the sentence difficult, but are also more error
     prone and more difficult to guess
```

c) sorted wordlists

```
   - the wordlist is sorted which allows for more efficient lookup of the code words
     (i.e. implementations can use binary search instead of linear search)
   - this also allows trie (a prefix tree) to be used, e.g. for better compression
```

The wordlist can contain native characters, but they must be encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD).

```
理想的wordlist应该有一下特点： 
    a）词的选择：知道前四个字母就可以确定一个单词。 
    b）避免相似的词：上面举了几个相似例子，会使得难以区分、难以猜测、容易出错。 
    c）排序处理：是为了在搜索时更加高效（比如使用二分查找代替线性查找），支持前缀树（为了压缩）。 
```

**主要是一些wordlist的要求和特点。**

**最下面那句，wordlist中可以包含最小的单词或者字母，但是必须使用NFKD形式进行编码。**

## From mnemonic to seed

A user may decide to protect their mnemonic with a passphrase. If a passphrase is not present, an empty string "" is used instead.

To create a binary seed from the mnemonic, we use the PBKDF2 function with a mnemonic sentence (in UTF-8 NFKD) used as the password and the string "mnemonic" + passphrase (again in UTF-8 NFKD) used as the salt. The iteration count is set to 2048 and HMAC-SHA512 is used as the pseudo-random function. The length of the derived key is 512 bits (= 64 bytes).

This seed can be later used to generate deterministic wallets using BIP-0032 or similar methods.

The conversion of the mnemonic sentence to a binary seed is completely independent from generating the sentence. This results in rather simple code; there are no constraints on sentence structure and clients are free to implement their own wordlists or even whole sentence generators, allowing for flexibility in wordlists for typo detection or other purposes.

Although using a mnemonic not generated by the algorithm described in "Generating the mnemonic" section is possible, this is not advised and software must compute a checksum for the mnemonic sentence using a wordlist and issue a warning if it is invalid.

The described method also provides plausible deniability, because every passphrase generates a valid seed (and thus a deterministic wallet) but only the correct one will make the desired wallet available.

```
*用户可以使用passphrase来保护助记符，如果不提供passphrase那么就用空字符串“”代替。 
*使用PBKDF2来生成seed：助记符做为密码，“mnemonic”||passphrase做为盐。迭代计数为2048，HMAC-SHA512为伪随机函数。派生出来的密钥长度为512位（64字节）。 
*seed的生成过程与助记符的生成过程完全独立。可以自主地实现自己的wordlist和整个助记符生成函数，有很高的灵活性。 
*在生成seed的过程中，要先检测输入的助记符是否合法，因为有可能不是使用助记符生成函数生成的。 
```

**seed的生成使用到了密钥派生函数PBKDF2，助记符是密码，“mnemonic”+passphrase为盐。规定了迭代次数、伪随机函数、派生密钥长度。而且助记符的生成过程和seed的生成过程独立分开，用户可以根据自己的需求设计不同的方案，比如用古诗词的wordlist还生成助记符。**

## Wordlists

- [Moved to separate document](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md)

- ### Chinese

  Chinese text typically does not use any spaces as word separators. For the sake of uniformity, we propose to use normal ASCII spaces (0x20) to separate words as per standard.

  **BIP39给出的wordlist中有中文简体和繁体的，而且每个word就是一个字，每个文件中有2018个字。因为中文编码的特殊性，建议使用ASCII码的0x20来进行分隔。**

## Test vectors

The test vectors include input entropy, mnemonic and seed. The passphrase "TREZOR" is used for all vectors.

<https://github.com/trezor/python-mnemonic/blob/master/vectors.json>

Also see <https://github.com/bip32JP/bip32JP.github.io/blob/master/test_JP_BIP39.json>

(Japanese wordlist test with heavily normalized symbols as passphrase) 

**日文的情况比较特殊，有单独passphrase.**

> "passphrase": "㍍ガバヴァぱばぐゞちぢ十人十色",

## Reference Implementation 参考实现

Reference implementation including wordlists is available from

<http://github.com/trezor/python-mnemonic>

## Other Implementations 其他一些实现

Go:

- <https://github.com/tyler-smith/go-bip39>

Elixir:

- <https://github.com/izelnakri/mnemonic>

Objective-C:

- <https://github.com/nybex/NYMnemonic>

Haskell:

- <https://github.com/haskoin/haskoin>

.NET C# (PCL):

- <https://github.com/Thashiznets/BIP39.NET>

.NET C# (PCL):

- <https://github.com/NicolasDorier/NBitcoin>

JavaScript:

- <https://github.com/bitpay/bitcore-mnemonic>
- <https://github.com/bitcoinjs/bip39> (used by [blockchain.info](https://github.com/blockchain/My-Wallet-V3/blob/v3.8.0/src/hd-wallet.js#L121-L146))

Ruby:

- <https://github.com/sreekanthgs/bip_mnemonic>

Rust:

- <https://github.com/infincia/bip39-rs>

Swift:

- <https://github.com/CikeQiu/CKMnemonic>
- <https://github.com/yuzushioh/WalletKit>

C++:

- <https://github.com/libbitcoin/libbitcoin/blob/master/include/bitcoin/bitcoin/wallet/mnemonic.hpp>

C (with Python/Java/Javascript bindings):

- <https://github.com/ElementsProject/libwally-core>



# GO语言代码

https://github.com/FactomProject/go-bip39

## example

```go
package main

import (
	"github.com/FactomProject/go-bip39"
	"github.com/FactomProject/go-bip32"
	"fmt"
)

func main(){
	// Generate a mnemonic for memorization or user-friendly seeds
	entropy, _ := bip39.NewEntropy(256)			//生成一个初始熵，256位
	mnemonic, _ := bip39.NewMnemonic(entropy)	//根据熵生成助记符

	// Generate a Bip32 HD wallet for the mnemonic and a user supplied password
	seed := bip39.NewSeed(mnemonic, "Secret Passphrase")	//根据助记符生成seed

	masterKey, _ := bip32.NewMasterKey(seed)	//使用BIP32生成masterkey
	publicKey := masterKey.PublicKey()

	fmt.Println("Mnemonic: ", mnemonic)
	fmt.Println("Seed", seed)
	fmt.Println("Master private key: ", masterKey)
	fmt.Println("Master public key: ", publicKey)
}
```

